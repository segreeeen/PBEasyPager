package net.swenf.pager;

import java.io.IOException;

import net.swenf.Tools;

/**
 * A helper-class for table/column layouts. Use the values generated by the
 * helper to print text in a table or column layout. <br/>
 * Use <code>setCurrentColumn()</code> to get the values for the specified
 * column. <br/>
 * <br/>
 * Make sure to set <code>yPos</code>, in case you are using <code>yPos</code>
 * for your text, to <code>updatePagerYPos()</code>, after your table is
 * finished.<br/>
 * <br/>
 * Be aware, that due to technical restrictions it is (at the moment) not
 * possible to break a page for one column only. As there is (at the moment) no
 * need to implement this, you will have to find a way yourself, if you want or
 * have to do so. It can be done for sure.
 * 
 * @author Felix Batusic
 *
 */
public class ColumnHelper {
    private float[] origXPos;
    private float[] curXPos;
    private float[] origYPos;
    private float[] curYPos;
    private float width;
    private int columns;
    private int currentColumn;
    private AbstractPager<?> pager;

    /**
     * Initializes for <code>columns</code> columns.
     * 
     * @param columns
     * @param pager
     */
    public ColumnHelper(int columns, AbstractPager<?> pager) {
	this.pager = pager;
	origXPos = Tools.splitPage(pager.getPageWidth(), pager.getMarginLeft(), columns);
	curXPos = Tools.splitPage(pager.getPageWidth(), pager.getMarginLeft(), columns);
	origYPos = new float[columns];
	curYPos = new float[columns];
	this.columns = columns;
	for (int i = 0; i < columns; i++) {
	    origYPos[i] = pager.yPos;
	    curYPos[i] = pager.yPos;
	}
	width = origXPos[1] - origXPos[0];
	currentColumn = 0;
    }

    /**
     * Initializes for <code>columns</code> columns, and a padding to the right.
     * 
     * @param columns
     * @param pager
     */
    public ColumnHelper(int columns, float padding, AbstractPager<?> pager) {
	this.pager = pager;
	origXPos = Tools.splitPage(pager.getPageWidth(), pager.getMarginLeft(), columns);
	curXPos = Tools.splitPage(pager.getPageWidth(), pager.getMarginLeft(), columns);
	origYPos = new float[columns];
	curYPos = new float[columns];
	this.columns = columns;
	for (int i = 0; i < columns; i++) {
	    origYPos[i] = pager.yPos;
	    curYPos[i] = pager.yPos;
	}
	width = (origXPos[1] - origXPos[0]) - padding;
	currentColumn = 0;
    }

    /**
     * Sets the internal currentColumn to a value. Change accordingly to get the
     * corresponding x and y positions for a column. This allows to print to
     * multiple columns at once without losing track of the yPositions.<br/>
     * <br/>
     * The columns start with 0 as the leftmost.
     * 
     * @param currentColumn
     */
    public void setCurrentColumn(int currentColumn) {
	if (currentColumn >= 0 && currentColumn < columns) {
	    this.currentColumn = currentColumn;
	} else {
	    throw new IllegalArgumentException("Value has to be in range.");
	}
    }

    /**
     * Get the width of a column.
     * 
     * @return
     */
    public float getWidth() {
	return width;
    }

    /**
     * Returns the x value for the current column.
     * 
     * @return
     */
    public float getX() {
	return curXPos[currentColumn];
    }

    /**
     * Returns the y value for the current column.
     * 
     * @return
     */
    public float getY() {
	return curYPos[currentColumn];
    }

    /**
     * Sets x and y to the correct value for the next line. Use getX() and
     * getY() to receive them.
     * 
     * @param marginTop
     *            additional margin to add to the line.
     * @throws IOException
     */
    public void nextLine(Float marginTop) throws IOException {
	if (marginTop != null) {
	    curXPos[currentColumn] = origXPos[currentColumn];
	    curYPos[currentColumn] -= pager.getLineHeight() + marginTop - PagerController.UNDER_LINE_CORRECTION;
	} else {
	    curXPos[currentColumn] = origXPos[currentColumn];
	    curYPos[currentColumn] -= pager.getLineHeight() - PagerController.UNDER_LINE_CORRECTION;
	}
    }

    /**
     * Sets x and y to the correct value for the next line. Use getX() and
     * getY() to receive them.
     * 
     * @throws IOException
     */
    public void nextLine() throws IOException {
	nextLine(null);
    }

    /**
     * Used to tell if the current x value exceeds the width of the column.
     * 
     * @return
     */
    public boolean xExceeded() {
	if (curXPos[currentColumn] > width) {
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Updates the internal Y values to match yPos. Use this, if you already
     * printed something using the yPos setup.
     */
    public void updateY() {
	for (int i = 0; i < columns; i++) {
	    origYPos[i] = pager.yPos;
	    curYPos[i] = pager.yPos;
	}
    }

    /**
     * Sets yPos of the pager to the y position of the column with the highest
     * y.
     */
    public void updatePagerYPos() {

	pager.yPos = getMinY();
    }

    /**
     * Draws a border around the columns
     */
    public void printBorder(float padding) {
	try {
	    float minY = getMinY();
	    pager.drawLine(pager.getMarginLeft() - padding, origYPos[0], pager.getMarginLeft() + padding, origYPos[0]);
	    pager.drawLine(pager.getMarginLeft() - padding, minY, pager.getMarginLeft() + padding, minY);
	} catch (IOException e) {
	    // TODO Auto-generated catch block
	    e.printStackTrace();
	}
    }

    private float getMinY() {
	float min = pager.yPos;
	for (float f : curYPos) {
	    if (f < min) {
		min = f;
	    }
	}
	return min;
    }

}
